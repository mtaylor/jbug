= JBug Newcastle: Ruby on Rails on TorqueBox

== 1. Installation

=== Prerequisites

  yum install -y gcc-c++ patch readline readline-devel zlib zlib-devel libyaml-devel libffi-devel openssl-devel make bzip2 autoconf automake libtool bison iconv-devel java

=== RVM

  # Run as user not root
  curl -L https://get.rvm.io | bash -s stable
  source ~/.bash_profile

Check out your personal message from Wayne.  So compassionate!

=== JRuby

  rvm install jruby

=== TorqueBox

  rvm use jruby
  rvm gemset create torquebox
  rvm use jruby-1.6.7.2@torquebox

  jruby -J-Xmx1024m -S gem install torquebox-server

== Running TorqueBox

TorqueBox creates a command line tool for managing your torquebox server.  You can checkout the avaiable commands through:

  torquebox

You can also checkout which versions of JBOSS, JRUBY and TORQUEBOX you are using.

  torquebox env

=== Starting TorqueBox

  torquebox run

=== Install rails

  gem install rails

== 2. Face Blog

Now that you have everything installed, you're ready to rock n roll.  It's time to create your first rails application.  You're going to create a new social networking site called Face Blog.

== Creating a Rails App

First thing you need to do is create a rails application.

  rails new face_blog

Notice the file structure.  Every rails app looks the same.  This makes it easy to quickly get involved in other rails projects.  The main areas you'll be working in today are:

app/* => Contains all your MVC files
config/ => Used to configure your app
db => where migrations and schema lives

== Adding gems

First thing we're going to add to our site is a User.  We want to allow the user to login, signup and all that jazz.  But of course we're not going to write all that ourselves.  We'll use a library to do the grunt work for us.

We're going to add "devise" (an authentication mechanism for rails) to our gem file

In the Gemfile, under

  gem "rails", "3.2.3"

Add

  gem devise

Then run bundler to pull in the dependecies into our gemset.

  bundle update

Devise is a rails engine (http://guides.rubyonrails.org/engines.html), don't worry about what engines are right now, we just need to know that we need to run some tasks specific to devise.

  rails devise:install
  rails generate devise:views

== Models and Migrations

To create our user model we'll use a model generator.  We don't always have to stick to the generators that come with rails.  3rd party libraries can also offer generators.  To see which generators you have avaiable to you.  You can run

  rails generate

For our user model we'll use the devise generator.

  rails generate devise User name:string dob:date

If you look at the migration that devise created (under db/migrate) you can see the extra information devise has added to support all forms of authentication.

Now that we've added some migrations we must migrate the database.

  rake db:migrate

We're also going to make the our attributes pubic.  We do this by setting the attr_accessible method offered by ActiveRecord::Base.  Open up the model app/models/user.rb and add in :name and :dob to the attr_accessible method:

  attr_accessible :email, :password, :password_confirmation, :remember_me, :name, :dob

== Validations

You can now test out your model in the rails console.

  rails c

  $> me = User.new(:name => "Martyn", :dob => "22/11/1984")

What happens why you try to save me

  $> me.save!

This happens because devise has added in some extra validation to our model.  We must enter an email, password, password_confirmation when creating a new user.  Let's try again.


  $> me = User.new(:name => "Martyn", :dob => "22/11/1984", :email => "mtaylor@redhat.com", :password => "password", :password_confirmation => "password")
  $> me.save!

Voila it works.  We can now be pretty confident our user works.

==== NOTE: 

Through out this practical your going to create many users.  Devise has a uniqueness validation on email address.  If you get complaints from Devise, you can just delete conflicting users.  To delete just call the destroy method on the user; you can delete all users using the command below:

  # Delete a single user
  me.destroy

  # Delete All Users
  User.all.each { |u| u.destroy }

Now we've seen devise validations in action, its time to add our own.  Face Blog is for over 18s only and user must supply a name.  Let's start by adding validation to make sure name is not empty.  Open up the user model, add in name validation.

  validates :name, :presence => true, :length => { :minimum => 2 }

This makes sure that a user supplies a name and its length greater than or equal to 2

Now time for checking the age.  We could use the rails helper methods for checking the age.  But instead we're going to create a custom method to stop underage users signing up.

  validates :dob, :presence => true
  validate :must_be_an_adult

  def must_be_an_adult
    if (Time.now - 18.years) < dob
      errors.add(:age, "must be over 18")
    end
  end

Try it out to see if its working.

  User.create!(:email => "mtaylor@redhat.com", :password => "password", :password_confirmation => "password", :dob => "01/01/2010", :name => "")  

== Associations

Face Blog allows users to add friends.  To do this wel'll need an extra model, we'll call it friendship.  This will be used to store mappings between users.  We'll setup model assoications to acheive the ERD show below:

link:images/first_model_erd.png

To start we need to create the extra friendship model.  We'll use a generator to do this.

  rails generate model Friendship user_id:integer friend_id:string

Note the naming convention here.  When we setup associations in rails, ActiveRecord automatically looks for a foreign key named <association_name>_id.  It's possible to override this, but we'll stick to convention for now to make it easy.

Next we need to add in the association into the models.

In the friendship model we add two associations

  belongs_to :user
  belongs_to :friend, :class_name => "User"

these associations link up the two ids we store to User objects.  For each friendship we can now get the User (the owner of the friendship) and the Friend (which is another User).

Now lets do the same on the User side.

  has_many :friendships
  has_many :friends, :through => :friendships

The last association is more of a convenience method.  Really we want to deal with friends not with friendships, ActiveRecord will look at the friendship Model for an association called :friend which we defined previously.

Now time to test it all out.  Lets create 2 users and make them friends with one another.

  # User 1
  martyn = User.create!(:email => "mtaylor@redhat.com", :password => "password", :password_confirmation => "password", :name => "martyn", :dob => "22/11/1984")

  # User 2
  dave = User.create!(:email => "dave@redhat.com", :password => "password", :password_confirmation => "password", :name => "Dave", :dob => "01/01/1950")

  # Add dave as a friend
  martyn.friends << dave
  martyn.save!

  # Check the relation
  martyn.friends

You might have noticed that dave still has no friends.  This is becuase we only set up the association in one direction.  We could add the inverse assoications to the user model, which would solve this issue.  But for the sake of simplicity we'll simply add an extra friendship entry.

  # Add Martyn as Daves friend
  dave.friends << martyn
  dave.save!  
  
=== Overview

There you have it.  You've successfully managed to create new models, migrations add validation and setup associations.  All in the space of a few minutes.  Next we'll start building up the Controller and View side of our applicaton.  We're going to need a ruby server running to test this.  If you haven't already, check out the Running TorqueBox section.  If your having trouble with TorqueBox don't worry you can just use the default ruby server for testing purposes.  To start it:

  rails s

== Controllers and Views

Now that we have the models complete.  We can start building our web application.  The first thing we're going to do is add in a controller and some views for managing our User.  Rails has a scaffolding mcahnism that generates a controller and views for standard CRUD operations.  As we'll see in a moment, these operations are associated with HTTP verbs and respond to endpoints conventional to REST.

we'll need to temporarily disable the devise namespace as it will conflict with out scaffold.  Open up config/routes.rb and comment out this line.

  # devise_for :users

Now, lets run the scaffold.  Since we've already created our migration we tell rails to skip it, we also tell rails to skip any files that conflict with the generated files, such as our user model.

  rails generate scaffold User --skip-migration --skip

You'll notce that rails create a bunch of files.  Ignore these, for now We're only intersted in the controller, views, and routes.rb.

Next thing we'll do is add our root route.  This the route that is initiated when a user first navigates to your application.  We'll set this as the index action of our users controller.  In routes.rb add:

  root :to => 'users#index'

whilst we're here we can uncomment the devise_for :users

  devise_for :users

Now, we just need to remove the default index.html file

  rm -f public/index.html

We'll add in some mock data so we can see the site in action.

  rake db:seed

Lets start up the server and see it in action.

  torquebox deploy
  torquebox run

Once torquebox has started navigate to http://localhost:8080

It's not particularly exciting right now.  But we'll jazz it up later.

The first thing we want to do is to add some links for logging in and out.  Since we want these on each page we visit, we'll add them to the application layout.  Open up app/views/applicaton.html.erb and add in the following content in the body tag before yield.

  <header>
    <% if user_signed_in? %>
       <%= "Hello  #{current_user.name}" %> |
       <%= link_to('Logout', destroy_user_session_path, :method => :delete) %>
    <% else %>
        <%= link_to('Login', new_user_session_path)  %> |
        <%= link_to('Register', new_user_registration_path) %>
    <% end %>
  </header>

Devise gives us helper methods to get the current_user and to check if a user is logged in.

Next we'll update the devise new registration view so that we can retrieve the name and dob.  Open up app/views/devise/registrations/new.html.erb and add in our extra content under the email section.  Notice we use the form helper methods here:

  <div><%= f.label :name %><br />
  <%= f.text_field :name %></div>

  <div><%= f.label :dob %><br />
  <%= f.date_select :dob, :start_year => 1900 %></div>

Great.  Now we can login, register and view users.  Next we want to allow users to add friends.  To handle friendships we'll create a new controller:

  rails generate controller friendships create destroy

Since we didn't we'll have to implement the actions ourselves.  Open up app/controllers/friendships_controller.rb and add in our business logic.

class FriendshipsController < ApplicationController
  def create
    friend = User.find(params[:id])

    current_user.friends << friend

    if current_user.save
      flash[:notice] = "Friend Added"
    else
      flash[:error] = "Unable to add friend"
    end
    redirect_to root_path
  end

  def destroy
    current_user.friends.delete(current_user.friends.find(params[:id]))

    if current_user.save
      flash[:notice] = "Friend Removed"
    else
      flash[:error] = "Unable to remove friend"
    end
    redirect_to root_path
  end

end


Next let's update the users list page and add a link for adding friends.

Remove the edit and destroy links and add in the links to create and remove friends.  We'll also remove the new user link whilst we're here.  (We use devise for handling registrations so we don't need to create users ourselves).

<h1>Listing users</h1>

<table>
  <tr>
    <th>Email</th>
    <th>Name</th>
    <th>Dob</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>

<% @users.each do |user| %>
  <tr>
    <td><%= user.email %></td>
    <td><%= user.name %></td>
    <td><%= user.dob %></td>
    <td><%= link_to 'Show', user %></td>
    <% if current_user %>
      <% if current_user.friends.include?(user) %>
        <td><%= link_to 'Remove Friends', friendship_path(:id => user), :method => :delete %></td>
      <% else %>
        <td><%= link_to 'Add Friend', friendships_path(:id => user), :method => :post %></td>
      <% end %>
    <% end %>
  </tr>
<% end %>
</table>

<br />

Lastly We add a section on our show user page to list their friends.

<p id="notice"><%= notice %></p>

<p>
  <b>Email:</b>
  <%= @user.email %>
</p>

<p>
  <b>Name:</b>
  <%= @user.name %>
</p>

<p>
  <b>Dob:</b>
  <%= @user.dob %>
</p>

<h3> Friends </h3>

<ul>
  <% @user.friends.each do |user| %>
    <li> <%= link_to user.email, user_path(user) %> </li>
  <% end %>
</ul>

<%= link_to 'Back', users_path %>













